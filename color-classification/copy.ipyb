### 리뷰 데이터 TEST

import numpy as np
import matplotlib.pyplot as plt
import torch
import torch.nn as nn
import torch.nn.functional as F
import torchvision
import torchvision.transforms as transforms
from PIL import Image
import os
from tqdm import tqdm

#### 테스트용

# 라벨을 숫자로 변환
labels_to_int = {'긴팔티': 0, '반팔티': 1, '셔츠/블라우스': 2, '니트웨어': 3, '후드티': 4, '민소매': 5,
                 '긴바지': 6, '반바지': 7, '롱스커트': 8, '미니스커트': 9, 
                 '코트': 10, '재킷': 11, '점퍼/짚업': 12, '패딩': 13, '가디건': 14, '베스트': 15, 
                 '원피스': 16, '점프수트': 17}

test_df = pd.read_csv('/home/j-j9s006/type-classification/review_test_label.csv')

test_df = test_df.dropna(subset=['type'])
test_df['type'] = test_df['type'].map(labels_to_int)
test_df['file_path'] = "/home/j-j9s006/type-classification/review_test/"+ test_df['file_name']

print(test_df)

#### 테스트용

# 데이터셋 정의
class CustomDataset(Dataset):
    def __init__(self, dataframe, image_path, transform=None):
        self.dataframe = dataframe
        self.image_path = image_path
        self.transform = transform

    def __len__(self):
        return len(self.dataframe)

    def __getitem__(self, idx):
        img_name = self.dataframe.iloc[idx, 0]
        img_path = self.image_path[idx]

        image = Image.open(img_path)

        if image.mode == 'RGBA':
            r, g, b, a = image.split()
            bg = Image.new('RGB', image.size, (255,255,255)) # 검정 배경
            bg.paste(image, mask=a)
            image = bg

        label = int(self.dataframe.iloc[idx, 1])

        if self.transform:
            image = self.transform(image)

        return image, label

def resize_and_pad(image, size=256):
    # 이미지의 원래 크기와 비율 계산
    w, h = image.size
    ratio = w / h

    # 장축을 256에 맞추고, 단축은 비율에 맞춰서 줄임
    if w > h:
        new_w = size
        new_h = int(size / ratio)
    else:
        new_h = size
        new_w = int(size * ratio)

    # 이미지 리사이즈
    resize_transform = transforms.Resize((new_h, new_w))
    image = resize_transform(image)

    # 빈 부분을 검정색으로 채우기
    pad_w = size - new_w
    pad_h = size - new_h

    pad_transform = transforms.Pad((pad_w // 2, pad_h // 2, pad_w - pad_w // 2, pad_h - pad_h // 2), fill=255)
    image = pad_transform(image)

    return image

transform = transforms.Compose(
    [
        transforms.Lambda(lambda img: resize_and_pad(img)),
        transforms.ToTensor(), 
        transforms.Normalize((0.5, 0.5, 0.5), (0.5, 0.5, 0.5))
    ]
)

review_dataset = CustomDataset(dataframe=test_df, image_path=test_df['file_path'].tolist(), transform=transform)
review_testloader = torch.utils.data.DataLoader(review_dataset, batch_size=8, shuffle=False, num_workers=2)

# 라벨을 숫자로 변환
int_to_labels = {0: '긴팔티', 1: '반팔티', 2: '셔츠/블라우스', 3: '니트웨어', 4: '후드티', 5: '민소매', 
                 6: '긴바지', 7: '반바지', 8: '롱스커트', 9: '미니스커트', 10: '코트', 
                 11: '재킷', 12: '점퍼/짚업', 13: '패딩', 14: '가디건', 15: '베스트', 16: '원피스', 17: '점프수트'}

def imshow(img):  
    # 텐서 이미지를 numpy로 변환
    img = img / 2 + 0.5  # unnormalize
    npimg = img.numpy()
    plt.imshow(np.transpose(npimg, (1, 2, 0)))  # RGB 형태로 변환하여 출력
    plt.show()

def test(model, testloader, criterion):
    model.eval()  # 모델을 평가 모드로 설정
    test_loss = 0.0
    correct = 0
    total = 0
    
    with torch.no_grad():  # Gradient 계산을 하지 않음 (테스트 중이므로 필요 없음)
        for i, data in tqdm(enumerate(testloader), total=len(testloader), desc="Testing"):
            inputs, labels = data
            imshow(inputs)
            inputs, labels = inputs.to(device), labels.to(device)
            
            outputs = model(inputs)
            loss = criterion(outputs, labels)
            test_loss += loss.item()
            
            _, predicted = outputs.max(1)
            total += labels.size(0)
            correct += predicted.eq(labels).sum().item()
            print('실제 라벨: ', int_to_labels[labels], ", 예측치: ", int_to_labels[predicted])

    accuracy = 100 * correct / total
    print(f"\nTest Loss: {test_loss/len(testloader)}, Accuracy: {accuracy:.2f}%")
    
    return accuracy, test_loss/len(testloader)

model = torchvision.models.efficientnet_v2_s(weights = None)
model.load_state_dict(torch.load('efficientnet_v2_s_type_ver1.pth', map_location = device))
model.classifier[1].out_features = 18

criterion = nn.CrossEntropyLoss()

# 이렇게 test 함수를 호출할 수 있습니다:
test_accuracy, test_loss = test(model, review_testloader, criterion)